# -*- coding: utf-8 -*-
from flask import make_response, jsonify
from flask_restful import Resource
from .definitions import SpatialExtent, DateTime, BandDescription
from .actinia_processing.actinia_interface import ActiniaInterface

__license__ = "Apache License, Version 2.0"
__author__ = "Sören Gebbert"
__copyright__ = "Copyright 2018, Sören Gebbert"
__maintainer__ = "Soeren Gebbert"
__email__ = "soerengebbert@googlemail.com"


strds_example = {
    "aggregation_type": "None",
    "bottom": "0.0",
    "creation_time": "2016-08-11 16:44:29.756411",
    "creator": "soeren",
    "east": "75.5",
    "end_time": "2013-07-01 00:00:00",
    "ewres_max": "0.25",
    "ewres_min": "0.25",
    "granularity": "1 month",
    "id": "precipitation_1950_2013_monthly_mm@PERMANENT",
    "map_time": "interval",
    "mapset": "PERMANENT",
    "max_max": "1076.9",
    "max_min": "168.9",
    "min_max": "3.2",
    "min_min": "0.0",
    "modification_time": "2016-08-11 16:45:14.032432",
    "name": "precipitation_1950_2013_monthly_mm",
    "north": "75.5",
    "nsres_max": "0.25",
    "nsres_min": "0.25",
    "number_of_maps": "762",
    "raster_register": "raster_map_register_934719ed2b4841818386a6f9c5f11b09",
    "semantic_type": "mean",
    "south": "25.25",
    "start_time": "1950-01-01 00:00:00",
    "temporal_type": "absolute",
    "top": "0.0",
    "west": "-40.5"
}


raster_example = {
    "cells": "2025000",
    "cols": "1500",
    "comments": "\"r.proj input=\"ned03arcsec\" location=\"northcarolina_latlong\" mapset=\"\\helena\" output=\"elev_ned10m\" method=\"cubic\" resolution=10\"",
    "creator": "\"helena\"",
    "database": "/tmp/gisdbase_75bc0828",
    "datatype": "FCELL",
    "date": "\"Tue Nov  7 01:09:51 2006\"",
    "description": "\"generated by r.proj\"",
    "east": "645000",
    "ewres": "10",
    "location": "nc_spm_08",
    "map": "elevation",
    "mapset": "PERMANENT",
    "max": "156.3299",
    "min": "55.57879",
    "ncats": "255",
    "north": "228500",
    "nsres": "10",
    "rows": "1350",
    "source1": "\"\"",
    "source2": "\"\"",
    "south": "215000",
    "timestamp": "\"none\"",
    "title": "\"South-West Wake county: Elevation NED 10m\"",
    "units": "\"none\"",
    "vdatum": "\"none\"",
    "west": "630000"
}

GET_DATA_PRODUCT_ID_EXAMPLE = {
    "product_id": "Sentinel-2A-L1C",
    "description": "Sentinel 2 Level-1C: Top-of-atmosphere reflectances in cartographic geometry",
    "source": "European Space Agency (ESA)",
    "extent": {
        "srs": "EPSG:4326",
        "left": -34,
        "right": 35,
        "bottom": 39,
        "top": 71
    },
    "time": {"from": "2016-01-01", "to": "2017-10-01"},
    "bands": [
        {
            "band_id": "1",
            "wavelength_nm": 443.9,
            "res_m": 60,
            "scale": 0.0001,
            "offset": 0,
            "type": "int16",
            "unit": "1"
        },
        {
            "band_id": "2",
            "name": "blue",
            "wavelength_nm": 496.6,
            "res_m": 10,
            "scale": 0.0001,
            "offset": 0,
            "type": "int16",
            "unit": "1"
        },
        {
            "band_id": "3",
            "name": "green",
            "wavelength_nm": 560,
            "res_m": 10,
            "scale": 0.0001,
            "offset": 0,
            "type": "int16",
            "unit": "1"
        },
        {
            "band_id": "4",
            "name": "red",
            "wavelength_nm": 664.5,
            "res_m": 10,
            "scale": 0.0001,
            "offset": 0,
            "type": "int16",
            "unit": "1"
        },
        {
            "band_id": "5",
            "wavelength_nm": 703.9,
            "res_m": 20,
            "scale": 0.0001,
            "offset": 0,
            "type": "int16",
            "unit": "1"
        },
        {
            "band_id": "6",
            "wavelength_nm": 740.2,
            "res_m": 20,
            "scale": 0.0001,
            "offset": 0,
            "type": "int16",
            "unit": "1"
        },
        {
            "band_id": "7",
            "wavelength_nm": 782.5,
            "res_m": 20,
            "scale": 0.0001,
            "offset": 0,
            "type": "int16",
            "unit": "1"
        },
        {
            "band_id": "8",
            "name": "nir",
            "wavelength_nm": 835.1,
            "res_m": 10,
            "scale": 0.0001,
            "offset": 0,
            "type": "int16",
            "unit": "1"
        },
        {
            "band_id": "8a",
            "wavelength_nm": 864.8,
            "res_m": 20,
            "scale": 0.0001,
            "offset": 0,
            "type": "int16",
            "unit": "1"
        },
        {
            "band_id": "9",
            "wavelength_nm": 945,
            "res_m": 60,
            "scale": 0.0001,
            "offset": 0,
            "type": "int16",
            "unit": "1"
        },
        {
            "band_id": "10",
            "wavelength_nm": 1373.5,
            "res_m": 60,
            "scale": 0.0001,
            "offset": 0,
            "type": "int16",
            "unit": "1"
        },
        {
            "band_id": "11",
            "wavelength_nm": 1613.7,
            "res_m": 20,
            "scale": 0.0001,
            "offset": 0,
            "type": "int16",
            "unit": "1"
        },
        {
            "band_id": "12",
            "wavelength_nm": 2202.4,
            "res_m": 20,
            "scale": 0.0001,
            "offset": 0,
            "type": "int16",
            "unit": "1"
        }
    ]
}

GET_DATA_PRODUCT_ID_DOC = {
    "summary": "Returns further information on a given EO product available at the back-end.",
    "description": "The request will ask the back-end for further details about a product "
                   "specified by the identifier `product_id`.",
    "tags": ["EO Data Discovery"],
    "parameters": [
        {
            "name": "product_id",
            "in": "path",
            "type": "string",
            "description": "product identifier string such as `MOD18Q1`",
            "required": True
        }
    ],
    "responses": {
        "200": {
            "description": "JSON object with metadata of the EO dataset.",
            "schema": {
                "type": "object",
                "required": ["product_id", "description", "extent", "bands"],
                "properties": {
                    "product_id": {"type": "string"},
                    "description": {"type": "string"},
                    "source": {"type": "string"},
                    "extent": SpatialExtent,
                    "time": DateTime,
                    "bands": {"type": "array", "items": BandDataTypes}
                },
                "additionalProperties": True
            },
            "examples": {"application/json": GET_DATA_PRODUCT_ID_EXAMPLE}
        },
        "401": {"$ref": "#/responses/auth_required"},
        "404": {"description": "EO dataset with specified identifier is not available"},
        "501": {"$ref": "#/responses/not_implemented"},
        "503": {"$ref": "#/responses/unavailable"}
    }
}


class DataProductId(Resource):

    def __init__(self):
        self.iface = ActiniaInterface()

    def get(self, product_id):

        # List strds maps from the GRASS location

        location, mapset, datatype, layer = self.iface.layer_def_to_components(product_id)

        status_code, layer_data = self.iface.layer_info(layer_name=product_id)
        if status_code != 200:
            return make_response(jsonify({"description": "An internal error occurred "
                                                         "while catching GRASS GIS layer information "
                                                         "for layer <%s>!\n Error: %s"
                                                         ""%(product_id, str(layer_data))}, 400))

        # Get the projection from the GRASS mapset
        status_code, mapset_info = self.iface.mapset_info(location=location, mapset=mapset)
        if status_code != 200:
            return make_response(jsonify({"description": "An internal error occurred "
                                                         "while catching mapset info "
                                                         "for mapset <%s>!"%mapset}, 400))

        description = "Raster dataset"
        if datatype.lower() == "strds":
            description = "Space time raster dataset"
        if datatype.lower() == "vector":
            description = "Vector dataset"

        source = "GRASS GIS location/mapset path: /%s/%s" % (location, mapset)
        srs = mapset_info["projection"]
        extent = SpatialExtent(left=float(layer_data["west"]),
                               right=float(layer_data["east"]),
                               top=float(layer_data["north"]),
                               bottom=float(layer_data["south"]),
                               srs=srs)

        print(layer_data)

        if datatype.lower() == "strds":
            time = DateTime()
            time["from"] = layer_data["start_time"]
            time["to"] = layer_data["end_time"]

            bands = BandDescription(band_id=product_id)

            info = dict(product_id=product_id,
                        extent=extent,
                        source=source,
                        description=description,
                        time=time,
                        bands=bands,
                        temporal_type=layer_data["start_time"],
                        number_of_maps=layer_data["number_of_maps"],
                        min_min=layer_data["min_min"],
                        min_max=layer_data["min_max"],
                        max_min=layer_data["max_min"],
                        max_max=layer_data["max_max"],
                        ewres_max=layer_data["ewres_max"],
                        ewres_min=layer_data["ewres_min"],
                        nsres_max=layer_data["nsres_max"],
                        nsres_min=layer_data["nsres_min"],
                        map_time=layer_data["map_time"],
                        granularity=layer_data["granularity"],
                        aggregation_type=layer_data["aggregation_type"],
                        creation_time=layer_data["creation_time"],
                        modification_time=layer_data["modification_time"],
                        mapset=mapset,
                        location=location)
        else:
            info = dict(product_id=product_id,
                        extent=extent,
                        source=source,
                        description=description,
                        mapset=mapset,
                        location=location,
                        title=layer_data["title"],
                        comments=layer_data["comments"],
                        datatype=layer_data["datatype"],
                        cells=layer_data["cells"],
                        cols=layer_data["cols"],
                        rows=layer_data["rows"],
                        ewres=layer_data["ewres"],
                        nsres=layer_data["nsres"],)

        return make_response(jsonify(info), 200)
